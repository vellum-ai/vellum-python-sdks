from typing import Any, ClassVar, Dict, Type, cast

from vellum.workflows.constants import VellumIntegrationProviderType
from vellum.workflows.references.trigger import TriggerAttributeReference
from vellum.workflows.triggers.base import BaseTriggerMeta
from vellum.workflows.triggers.integration import IntegrationTrigger
from vellum.workflows.utils.uuids import uuid4_from_hash


class VellumIntegrationTriggerMeta(BaseTriggerMeta):
    """
    Custom metaclass for VellumIntegrationTrigger that supports dynamic attribute discovery.

    This metaclass extends BaseTriggerMeta to enable class-level access to attributes
    that aren't statically defined. When accessing an undefined attribute on a
    VellumIntegrationTrigger class, this metaclass will create a TriggerAttributeReference
    dynamically, allowing triggers to work with attributes discovered at runtime from
    integration APIs or event payloads.
    """

    def __getattribute__(cls, name: str) -> Any:
        """
        Override attribute access to support dynamic attribute discovery.

        For VellumIntegrationTrigger classes generated by the factory, this method
        allows access to any attribute name, creating TriggerAttributeReference objects
        on demand. This enables usage like:

            SlackMessage = VellumIntegrationTrigger.for_trigger("SLACK", "NEW_MESSAGE")
            text = SlackMessage.message  # Creates reference even though 'message' isn't pre-defined

        Args:
            name: The attribute name being accessed

        Returns:
            The attribute value or a dynamically created TriggerAttributeReference
        """
        # Let BaseTriggerMeta handle internal attributes and known attributes
        try:
            return super().__getattribute__(name)
        except AttributeError:
            # For VellumIntegrationTrigger factory-generated classes, create dynamic references
            # Only enable dynamic attribute creation for factory-generated classes, not the base
            # VellumIntegrationTrigger class itself. Factory classes have names like:
            # "VellumIntegrationTrigger_COMPOSIO_SLACK_NEW_MESSAGE"
            try:
                is_factory_class = super().__getattribute__("__name__").startswith(
                    "VellumIntegrationTrigger_"
                ) and not name.startswith("_")
            except AttributeError:
                is_factory_class = False

            if is_factory_class:
                # Import here to avoid circular dependency
                from vellum.workflows.references.trigger import TriggerAttributeReference

                trigger_cls = cast(Type["VellumIntegrationTrigger"], cls)

                # Check cache first
                cache = super().__getattribute__("__trigger_attribute_cache__")
                if name in cache:
                    return cache[name]

                # Generate and store deterministic UUID for this attribute if not already present.
                # This ensures consistent IDs across multiple accesses to the same attribute,
                # which is critical for serialization and state resolution.
                attribute_ids = super().__getattribute__("__trigger_attribute_ids__")
                if name not in attribute_ids:
                    attribute_ids[name] = uuid4_from_hash(f"{trigger_cls.__qualname__}|{name}")

                # Create a new dynamic reference for this attribute
                # For dynamic attributes, we use Any as the type since we don't know the type ahead of time
                types = (object,)
                reference = TriggerAttributeReference(name=name, types=types, instance=None, trigger_class=trigger_cls)
                cache[name] = reference
                return reference

            # Not a factory class or starts with _, re-raise the AttributeError
            raise


class VellumIntegrationTrigger(IntegrationTrigger, metaclass=VellumIntegrationTriggerMeta):
    """
    Factory-based trigger for Vellum-managed integration events.

    VellumIntegrationTrigger provides a pure factory pattern for creating trigger
    classes dynamically based on integration provider, integration name, and trigger name.
    Unlike predefined trigger classes, these triggers are created on-demand and support
    dynamic attribute discovery from the integration API.

    This design ensures parity with VellumIntegrationToolDefinition and allows users to
    work with any integration trigger without requiring SDK updates for new integrations.

    Examples:
        Create triggers dynamically for different integrations:
            >>> SlackNewMessage = VellumIntegrationTrigger.for_trigger(
            ...     integration_name="SLACK",
            ...     trigger_name="SLACK_NEW_MESSAGE"
            ... )
            >>>
            >>> GithubPush = VellumIntegrationTrigger.for_trigger(
            ...     integration_name="GITHUB",
            ...     trigger_name="GITHUB_PUSH"
            ... )

        Use in workflow graph:
            >>> class MyWorkflow(BaseWorkflow):
            ...     graph = SlackNewMessage >> ProcessMessageNode

        Reference trigger attributes in nodes:
            >>> class ProcessNode(BaseNode):
            ...     class Outputs(BaseNode.Outputs):
            ...         text = SlackNewMessage.message
            ...         channel = SlackNewMessage.channel

        Instantiate for testing:
            >>> trigger = SlackNewMessage(event_data={
            ...     "message": "Hello world",
            ...     "channel": "C123456"
            ... })
            >>> trigger.message
            'Hello world'

    Note:
        The factory method generates unique classes with proper __name__ and __module__
        for correct attribute ID generation and serialization. Each factory call with
        the same parameters returns the same class instance (cached).
    """

    # Class variables that identify this trigger
    provider: ClassVar[VellumIntegrationProviderType]
    integration_name: ClassVar[str]
    trigger_name: ClassVar[str]

    # Cache for generated trigger classes to ensure consistency
    _trigger_class_cache: ClassVar[Dict[tuple, Type["VellumIntegrationTrigger"]]] = {}

    def __init__(self, event_data: dict):
        """
        Initialize trigger with event data from the integration.

        The trigger dynamically populates its attributes based on the event_data
        dictionary keys. Any key in event_data becomes an accessible attribute.

        Args:
            event_data: Raw event data from the integration. Keys become trigger attributes.

        Examples:
            >>> SlackMessage = VellumIntegrationTrigger.for_trigger("SLACK", "SLACK_NEW_MESSAGE")
            >>> trigger = SlackMessage(event_data={
            ...     "message": "Hello",
            ...     "channel": "C123",
            ...     "user": "U456"
            ... })
            >>> trigger.message
            'Hello'
            >>> trigger.channel
            'C123'
        """
        super().__init__(event_data)

        # Dynamically populate instance attributes from event_data.
        # This allows any key in event_data to become an accessible attribute:
        # event_data={"message": "Hi"} â†’ trigger.message == "Hi"
        for key, value in event_data.items():
            setattr(self, key, value)

    def to_trigger_attribute_values(self) -> Dict["TriggerAttributeReference[Any]", Any]:
        """
        Materialize attribute descriptor/value pairs for this trigger instance.

        For VellumIntegrationTrigger, this includes all dynamic attributes from event_data.
        """
        from vellum.workflows.references.trigger import TriggerAttributeReference

        attribute_values: Dict["TriggerAttributeReference[Any]", Any] = {}

        # Unlike the base class which iterates over type(self) (predefined annotations),
        # we iterate over event_data keys since our attributes are discovered dynamically at runtime.
        # The base class approach: for reference in type(self)
        # Our approach: for attr_name in self._event_data.keys()
        for attr_name in self._event_data.keys():
            # Get the class-level reference for this attribute
            # This will create it via our custom metaclass if it doesn't exist
            reference = getattr(type(self), attr_name)
            if isinstance(reference, TriggerAttributeReference):
                attribute_values[reference] = getattr(self, attr_name)

        return attribute_values

    @classmethod
    def for_trigger(
        cls,
        integration_name: str,
        trigger_name: str,
        provider: str = "COMPOSIO",
    ) -> Type["VellumIntegrationTrigger"]:
        """
        Factory method to create a new trigger class for a specific integration trigger.

        This method generates a unique trigger class that can be used in workflow graphs
        and node definitions. Each unique combination of provider, integration_name, and
        trigger_name produces the same class instance (cached).

        Args:
            integration_name: The integration identifier (e.g., "SLACK", "GITHUB")
            trigger_name: The specific trigger identifier (e.g., "SLACK_NEW_MESSAGE")
            provider: The integration provider (default: "COMPOSIO")

        Returns:
            A new trigger class configured for the specified integration trigger

        Examples:
            >>> SlackNewMessage = VellumIntegrationTrigger.for_trigger(
            ...     integration_name="SLACK",
            ...     trigger_name="SLACK_NEW_MESSAGE"
            ... )
            >>> type(SlackNewMessage).__name__
            'VellumIntegrationTrigger_COMPOSIO_SLACK_SLACK_NEW_MESSAGE'
            >>>
            >>> # Use in workflow
            >>> class MyWorkflow(BaseWorkflow):
            ...     graph = SlackNewMessage >> ProcessNode

        Note:
            The generated class has proper __name__, __module__, and __qualname__
            for correct serialization and attribute ID generation.
        """
        # Validate and normalize provider
        provider_enum = VellumIntegrationProviderType(provider)

        # Create cache key
        cache_key = (provider_enum.value, integration_name, trigger_name)

        # Return cached class if it exists
        if cache_key in cls._trigger_class_cache:
            return cls._trigger_class_cache[cache_key]

        # Generate unique class name including provider to avoid collisions across providers
        class_name = f"VellumIntegrationTrigger_{provider_enum.value}_{integration_name}_{trigger_name}"

        # Create the new trigger class
        trigger_class = type(
            class_name,
            (cls,),
            {
                "provider": provider_enum,
                "integration_name": integration_name,
                "trigger_name": trigger_name,
                "__module__": cls.__module__,
                # Explicitly set __qualname__ to match __name__ for deterministic UUID generation.
                # UUIDs are generated from __qualname__, so this must be consistent and unique
                # across different trigger configurations to prevent ID collisions.
                "__qualname__": class_name,
            },
        )

        # Cache the generated class
        cls._trigger_class_cache[cache_key] = trigger_class

        return trigger_class
