# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel, update_forward_refs
from .api_node_result_data import ApiNodeResultData
from .code_execution_node_result_data import CodeExecutionNodeResultData
from .conditional_node_result_data import ConditionalNodeResultData
from .map_node_result_data import MapNodeResultData
from .merge_node_result_data import MergeNodeResultData
from .prompt_node_result_data import PromptNodeResultData
from .search_node_result_data import SearchNodeResultData
from .subworkflow_node_result_data import SubworkflowNodeResultData
from .templating_node_result_data import TemplatingNodeResultData
from .terminal_node_result_data import TerminalNodeResultData


class WorkflowNodeResultData_Prompt(UniversalBaseModel):
    type: typing.Literal["PROMPT"] = "PROMPT"
    data: PromptNodeResultData

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WorkflowNodeResultData_Search(UniversalBaseModel):
    type: typing.Literal["SEARCH"] = "SEARCH"
    data: SearchNodeResultData

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WorkflowNodeResultData_Templating(UniversalBaseModel):
    type: typing.Literal["TEMPLATING"] = "TEMPLATING"
    data: TemplatingNodeResultData

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WorkflowNodeResultData_CodeExecution(UniversalBaseModel):
    type: typing.Literal["CODE_EXECUTION"] = "CODE_EXECUTION"
    data: CodeExecutionNodeResultData

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WorkflowNodeResultData_Conditional(UniversalBaseModel):
    type: typing.Literal["CONDITIONAL"] = "CONDITIONAL"
    data: ConditionalNodeResultData

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WorkflowNodeResultData_Api(UniversalBaseModel):
    type: typing.Literal["API"] = "API"
    data: ApiNodeResultData

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WorkflowNodeResultData_Terminal(UniversalBaseModel):
    type: typing.Literal["TERMINAL"] = "TERMINAL"
    data: TerminalNodeResultData

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


from .array_vellum_value import ArrayVellumValue  # noqa: E402, F401, I001


class WorkflowNodeResultData_Merge(UniversalBaseModel):
    type: typing.Literal["MERGE"] = "MERGE"
    data: MergeNodeResultData

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WorkflowNodeResultData_Subworkflow(UniversalBaseModel):
    type: typing.Literal["SUBWORKFLOW"] = "SUBWORKFLOW"
    data: typing.Optional[SubworkflowNodeResultData] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WorkflowNodeResultData_Metric(UniversalBaseModel):
    type: typing.Literal["METRIC"] = "METRIC"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WorkflowNodeResultData_Map(UniversalBaseModel):
    type: typing.Literal["MAP"] = "MAP"
    data: typing.Optional[MapNodeResultData] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


WorkflowNodeResultData = typing.Union[
    WorkflowNodeResultData_Prompt,
    WorkflowNodeResultData_Search,
    WorkflowNodeResultData_Templating,
    WorkflowNodeResultData_CodeExecution,
    WorkflowNodeResultData_Conditional,
    WorkflowNodeResultData_Api,
    WorkflowNodeResultData_Terminal,
    WorkflowNodeResultData_Merge,
    WorkflowNodeResultData_Subworkflow,
    WorkflowNodeResultData_Metric,
    WorkflowNodeResultData_Map,
]
update_forward_refs(WorkflowNodeResultData_Templating)
update_forward_refs(WorkflowNodeResultData_CodeExecution)
update_forward_refs(WorkflowNodeResultData_Terminal)
